# Simple SQLite Clone in C++

A step-by-step implementation of a SQLite-compatible database from scratch in C++, designed to learn systems programming and database internals.

## üéØ Educational Goals
- **Systems Programming**: Manual memory management, binary file I/O, and paging.
- **Database Internals**: Understanding B-Trees, Virtual Machines, and Buffer Pools.
- **OS Concepts**: How databases interact with the Operating System (fsync, cache).

## üèóÔ∏è High-Level Architecture

The database is structured in modular layers, processing a query from text to disk:

1.  **REPL (Read-Eval-Print Loop)**:
    -   Takes user input (SQL or meta-commands like `.exit`).
    -   Passes input to the Tokenizer.

2.  **Tokenizer & Parser**:
    -   Converts text string (`"select * from users"`) into a byte-code or internal representation.
    -   Checks for syntax errors.

3.  **Virtual Machine (VM)**:
    -   Executes the bytecode generated by the parser.
    -   Acts as the bridge between the query logic and the data structures.

4.  **B-Tree**:
    -   The core data structure for storing rows.
    -   Allows for fast insertion, deletion, and search ($O(\log N)$).
    -   Splits internal nodes and leaf nodes to maintain balance.

5.  **Pager**:
    -   Manages pages (fixed-size blocks of memory, e.g., 4KB) read from and written to the disk.
    -   Handles caching (Buffer Pool) to minimize disk I/O.

6.  **OS Interface**:
    -   Low-level file operations (`open`, `read`, `write`, `lseek`).

## üó∫Ô∏è Roadmap

### Phase 1: The Frontend
- [x] **Step 1: REPL**: A simple command-line loop that accepts input.
- [x] **Step 2: Command Processor**: Distinguishing Meta-Commands from SQL Statements and basic compilation.

### Phase 2: The Backend (In-Memory)
- [ ] **Step 3: In-Memory Append-Only Table**: Hardcoded table schema and paging.
- [ ] **Step 4: Testing**: Basic unit tests for the database.

### Phase 3: Persistence
- [ ] **Step 5: Pager**: Reading/Writing 4KB pages to disk.
- [ ] **Step 6: Cursor**: Abstraction for iterating over the table.

### Phase 4: B-Tree Implementation
- [ ] **Step 7: Leaf Node Format**: Storing rows in B-Tree leaves.
- [ ] **Step 8: Internal Node Format**: Routing logic for the B-Tree.
- [ ] **Step 9: Splitting**: Handling full nodes.

## üöÄ Build & Run

### Prerequisites
- A C++ compiler (g++ or clang++)
- Make (optional)

### Compilation
```bash
g++ db.cpp -o db
```

### Usage
```bash
./db
```
Type `.exit` to quit.
