# Simple SQLite Clone in C++

A step-by-step implementation of a SQLite-compatible database from scratch in C++, designed to learn systems programming and database internals.

## üéØ Educational Goals

- **Systems Programming**: Manual memory management, binary file I/O, and paging.
- **Database Internals**: Understanding B-Trees, Virtual Machines, and Buffer Pools.
- **OS Concepts**: How databases interact with the Operating System (fsync, cache).

## üèóÔ∏è High-Level Architecture

The database is structured in modular layers, processing a query from text to disk:

1.  **REPL (Read-Eval-Print Loop)**:

    - Takes user input (SQL or meta-commands like `.exit`).
    - Passes input to the Tokenizer.

2.  **Tokenizer & Parser**:

    - Converts text string (`"select * from users"`) into a byte-code or internal representation.
    - Checks for syntax errors.

3.  **Virtual Machine (VM)**:

    - Executes the bytecode generated by the parser.
    - Acts as the bridge between the query logic and the data structures.

4.  **B-Tree**:

    - The core data structure for storing rows.
    - Allows for fast insertion, deletion, and search ($O(\log N)$).
    - Splits internal nodes and leaf nodes to maintain balance.

5.  **Pager**:

    - Manages pages (fixed-size blocks of memory, e.g., 4KB) read from and written to the disk.
    - Handles caching (Buffer Pool) to minimize disk I/O.

6.  **OS Interface**:
    - Low-level file operations (`open`, `read`, `write`, `lseek`).

## üó∫Ô∏è Roadmap

### Phase 1: The Frontend ‚úÖ

- [x] **Step 1: REPL**: A simple command-line loop that accepts input.
- [x] **Step 2: Command Processor**: Distinguishing Meta-Commands from SQL Statements and basic compilation.

### Phase 2: The Backend (In-Memory) üöß

- [x] **Step 3: Basic Schema**: Defined table schema with `id`, `username`, and `email` fields.
- [x] **Step 4: Statement Preparation**: INSERT and SELECT statement parsing with validation.
- [ ] **Step 5: B-Tree Implementation**: Replace array-based storage with B-Tree data structure.

### Phase 3: B-Tree Implementation (In Progress)

- [ ] **Step 6: Node Structure**: Define B-Tree node structure and basic operations.
- [ ] **Step 7: Insertion Logic**: Implement insertion with node splitting.
- [ ] **Step 8: Search \u0026 Traversal**: Implement search by ID and tree traversal.
- [ ] **Step 9: Integration**: Connect B-Tree with INSERT/SELECT commands.

### Phase 4: Persistence (Future)

- [ ] **Step 10: Pager**: Reading/Writing 4KB pages to disk.
- [ ] **Step 11: Cursor**: Abstraction for iterating over the table.
- [ ] **Step 12: Persistent B-Tree**: Store B-Tree nodes on disk.

## üöÄ Build & Run

### Prerequisites

- A C++ compiler (g++ or clang++)
- Make (optional)

### Compilation

```bash
g++ db.cpp -o db
```

### Usage

```bash
./db
```

Type `.exit` to quit.
